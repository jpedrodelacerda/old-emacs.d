#+TITLE: Emacs Configuration
#+AUTHOR: João Pedro de Lacerda
#+EMAIL: jpedrodelacerda@gmail.com
#+OPTIONS: toc:nil num:nil

* $ whoami

#+BEGIN_SRC emacs-lisp
  (setq home (concat "/home/" (eval user-login-name)))
#+END_SRC

Enable ssh-agent for emacs server
#+BEGIN_SRC emacs-lisp
  (use-package keychain-environment
    :init (keychain-refresh-environment))
#+END_SRC


* Configure =use-package=

  This setup uses =use-package= to make sure that all packages are installed before loading them.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

Also, to ensure we always compile and use updated packages:

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+END_SRC


* =evil-mode=

  Disable abbrev expansion when hitting Escape.

#+BEGIN_SRC emacs-lisp
 (setq evil-want-abbrev-expand-on-insert-exit nil) 
#+END_SRC  

  Use =evil=:

#+BEGIN_SRC emacs-lisp
  (use-package evil
	:config
	(evil-mode 1)
    (setq evil-emacs-state-mode nil)
	:bind
	("C-s" . evil-write))
#+END_SRC

  Enable =surround= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+END_SRC

  Setting up =evil-org=:

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda () (evil-org-set-key-theme))))
#+END_SRC


* Utilities

#+BEGIN_SRC emacs-lisp

  (defun jpdl/create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent."
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))

  (defun jpdl/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun jpdl/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC


* UI Preferences
  

** Tweaking Window

***   Disabling menu bar and scroll bar because they just take space up.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

*** Disabling blinking cursor

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC
*** Getting rid of the tiny scroll bar on minibuffer:

#+BEGIN_SRC emacs-lisp
   (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC

*** We probably know which window we are using and where, so let's make the windows title more useful.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC


** No start-up-message
   
  Really, why would I want this?

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC


** Theming

*** First we need =all-the-icons=

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

*** Back to gruvbox.

#+BEGIN_SRC emacs-lisp
  (use-package gruvbox-theme 
    :config
	(load-theme 'gruvbox-dark-soft)
    (enable-theme 'gruvbox-dark-soft))
#+END_SRC

*** Powerline and airline-theme 

#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :init
    (setq powerline-default-separator 'arrow
          powerline-default-separator-dir (quote (left . right))
          powerline-height 18
          powerline-display-buffer-size nil
          powerline-display-hud nil
          powerline-display-mule-info nil
          powerline-gui-use-vcs-glyph t
          powerline-inactive1 '((t (:background "grey11" :foreground "#c5c8c6")))
          powerline-inactive2 '((t (:background "grey20" :foreground "#c5c8c6"))))
    :config
    (powerline-default-theme))
#+END_SRC
 
#+BEGIN_SRC emacs-lisp
  (use-package airline-themes
	:config
	(load-theme 'airline-gruvbox-dark t))
#+END_SRC
 
  # ICONS!!!
  # 
# #+BEGIN_SRC emacs-lisp
  # (defun powerline-get-icon (name alt-sym help-message)
    # "Returns a propertized icon if available, otherwise, returns ALT-SYM."
    # (propertize alt-sym 'help-echo help-message))
	# 
  # (defun powerline-modified ()
    # (condition-case ex
        # (let ((state (vc-git-state (buffer-file-name))))
          # (cond ((buffer-modified-p)  (powerline-get-icon "pencil" "✦" "Modified buffer"))
                # ((eq state 'edited)   (powerline-get-icon "pencil" "✦" "Modified buffer, unregistered changes"))
                # ((eq state 'unregistered) (powerline-get-icon "question" "❓" "Unregistered file in VCS"))
                # ((eq state 'missing)  (powerline-get-icon "exclamation" "⁈" "File exists only in VCS, not on the hard disk"))
                # ((eq state 'ignored)  (powerline-get-icon "ban" "♟" "Ignored file in VCS"))
                # ((eq state 'added)    (powerline-get-icon "plus" "➕" "File will be registered in VCS in the next commit"))
                # (t " ")))
      # (error (powerline-get-icon "exclamation" "⁈" (car ex)))))
# #+END_SRC



** And this is supposed to be (+18), so no minors. (Just kidding, if you're under 18 just go play some Magic or whatever)

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config
	(minions-mode 1))
#+END_SRC


** Font and resizing

#+BEGIN_SRC emacs-lisp
  (setq default-font "Fira Code")
  (setq default-font-size 10)
  (setq current-font-size default-font-size)
  
  (setq font-change-increment 1.1)
  
  (defun font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat default-font "-" (number-to-string current-font-size)))
  
  (defun set-font-size ()
    "Set the font to `default-font' at `current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))
  
  (defun reset-font-size ()
    "Change font size back to `default-font-size'."
    (interactive)
    (setq current-font-size default-font-size)
    (set-font-size))
  
  (defun increase-font-size ()
    "Increase current font size by a factor of `font-change-increment'."
    (interactive)
    (setq current-font-size
          (ceiling (* current-font-size font-change-increment)))
    (set-font-size))
  
  (defun decrease-font-size ()
    "Decrease current font size by a factor of `font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq current-font-size
          (max 1
               (floor (/ current-font-size font-change-increment))))
    (set-font-size))
  
  (define-key global-map (kbd "C-)") 'reset-font-size)
  (define-key global-map (kbd "C-+") 'increase-font-size)
  (define-key global-map (kbd "C-=") 'increase-font-size)
  (define-key global-map (kbd "C-_") 'decrease-font-size)
  (define-key global-map (kbd "C--") 'decrease-font-size)
  
  (reset-font-size)
#+END_SRC


** Handling buffers/windows and shit

#+BEGIN_SRC emacs-lisp
  (defun split-window-vertically-and-switch ()
	"After splitting the window, also switch to it."
	(interactive)
	(split-window-vertically)
	(other-window 1))

  (defun split-window-horizontally-and-switch ()
	"After splitting the window, also switch to it."
	(interactive)
	(split-window-horizontally)
	(other-window 1))

#+END_SRC


  To move between buffers with Meta and arrows
#+BEGIN_SRC emacs-lisp
  (use-package windmove
	:bind (("M-<up>"    . windmove-up   )
		   ("M-<down>"  . windmove-down )
		   ("M-<right>" . windmove-right)
		   ("M-<left>"  . windmove-left )
		   ("C-M-r"     . split-window-horizontally-and-switch)
		   ("C-M-d"     . split-window-vertically-and-switch)
           ))
#+END_SRC


** Excuse me, sir. Do you know where I am?

  Async relative line numbering

#+BEGIN_SRC emacs-lisp
  (use-package nlinum-relative
	:config
	(global-nlinum-relative-mode)
	(nlinum-relative-setup-evil))
#+END_SRC


** Highlighting the uncommitted changes

  Use =diff-hl= to highlight uncommitted changes when programming.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
	:config
	(add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
	(add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+END_SRC


* Project Management

  Some general packages for like... everything. From writing to programming.
  Auto-completion, searches, version control...

** =ag=

  Extremely powerful searcher. Haven't decided between this and =helm-ag=, tho.

#+BEGIN_SRC emacs-lisp
  (use-package ag)
#+END_SRC

** =helm=

  Well, helm is awesome, right. So why the +hell+ heck not?!
  Here I set:
    - =helm-map= keys:
		  - =TAB= to execute some action,
		  - =C-z= to select
	- General shortcuts:
		  - =C-x C-b= to open helm-mini
		  - =C-x C-f= to find file with helm
		  - =C-x C-d= to find file with helm on projectile

#+BEGIN_SRC emacs-lisp
  (use-package helm
	:config
	(helm-autoresize-mode 1)
	(setq helm-autoresize-min-height 25)
	(setq helm-autoresize-max-height 35)
	(define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
	(define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
	(define-key helm-map (kbd "C-z") #'helm-select-action)
	:bind (("C-x C-b" . helm-mini)
	       ("C-x C-f" . helm-find-files)
	       ("C-x C-d" . helm-projectile-find-file)))
#+END_SRC
   

** =company=

  I mean... we want this all the time, right?!
  Here I set:
	- Company to sort suggestions by occurrence
    - General shortcuts:
		  - =C-TAB= to select next suggestion
		  - =C-'= to accept suggestion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-transformers '(company-sort-by-occurrence))
    :bind
    ("C-<tab>" . company-complete-common-or-cycle)
	("C-'" . company-complete))

  (global-company-mode)

#+END_SRC

  Company with fuzzing...

#+BEGIN_SRC emacs-lisp
  (use-package company-flx
    :after
    (company)
	:config
	(company-flx-mode +1))
#+END_SRC

** =lsp-mode=

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
	:hook (
	  (go-mode . lsp)
	  (python-mode . lsp))
	:commands lsp)

	  (defvar lsp-language-id-configuration
	   '((go-mode . "go")
		 (anaconda-mode . "python")))

  (use-package lsp-ui
	:commands lsp-ui-mode)

  (use-package company-lsp
	:commands company-lsp)

  (use-package helm-lsp
	:commands helm-lsp-workspace-symbol)
#+END_SRC

** =dumb-jump=

  It seems nice and handy. Because it is.
  Here I set:
    - General shortcuts:
	  - =M-.= to jump to definition
	  - =M-g j= to jump to definition
	  - =M-g o= jump on other window
	  - =M-g x= jump to external
	  - =M-g z= jump to external on other window

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
	:bind (
    ("M-." . dumb-jump-go)
    ("M-g o" . dumb-jump-go-other-window)
	("M-g j" . dumb-jump-go)
	("M-g i" . dumb-jump-go-prompt)
	("M-g x" . dumb-jump-go-prefer-external)
	("M-g z" . dumb-jump-go-prefer-external-other-window))
    :config
    (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
	(setq dumb-jump-selector 'ivy))
#+END_SRC

** =flycheck=

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config
    (global-flycheck-mode))
#+END_SRC

** =magit=

  Magit rocks, there's no denying. Using =evil= keybindings with =evil-mode=
  Here I set:
    - General shortcuts:
		  - =C-x g= to see status menu
	- following [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes beyond 50 characters
	- starting commit message buffer with insert state

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)
  
    :config
    (use-package evil-magit)
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
  
    ;;(with-eval-after-load 'magit-remote
    ;;(magit-define-popup-action 'magit-push-popup ?P
    ;;    'magit-push-implicitly--desc
    ;;    'magit-push-implicitly ?p t))
  
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

  =evil-magit=

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit)
#+END_SRC


** =projectile= 

  Well, projectile is the way to go when we talk about projects on emacs.
  Here I set:
    - General shortcuts:
		  - =C-c p= to projectile menu
				- 4: other-window
				- 5: other-frame
				- s: search
				- x: execute
	- Completion: helm

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-mode 1)
  (setq projectile-project-search-path '("~/"))
  (setq projectile-completion-system 'helm)
  (which-key-add-key-based-replacements "C-c p 4" "other-window"
                                        "C-c p 5" "other-frame"
                                        "C-c p s" "search"
                                        "C-c p x" "execute")
  :bind-keymap ("C-c p" . projectile-command-map))
#+END_SRC

** =treemacs= and =treemacs-evil=

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :config
    (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
    :bind ("M-v" . treemacs ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-evil)
#+END_SRC

** =helm-company=

  If I ever want to complete with helm, just =C-:=.
#+BEGIN_SRC emacs-lisp
  (use-package helm-company
    :bind ("C-:" . helm-company))
#+END_SRC

** =helm-projectile=

  Helm all the way, bro.
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure t
    :init (helm-projectile-on))
#+END_SRC

** =undo-tree=

   Because shit happens.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)
#+END_SRC

** =smartparens=

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :init
    :bind ("C-SPC" . sp-forward-sexp)
    :config
    (sp-pair "{" nil :post-handlers '((jpdl/create-newline-and-enter-sexp "RET")))
    (sp-pair "[" nil :post-handlers '((jpdl/create-newline-and-enter-sexp "RET")))
    (sp-pair "(" nil :post-handlers '((jpdl/create-newline-and-enter-sexp "RET")))
    (require 'smartparens-config)
    (smartparens-global-mode 1))
#+END_SRC

** =rainbow-delimiters=

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** =Nerd-Commenter=

#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
	:bind ("M-;" . evilnc-comment-or-uncomment-lines))
#+END_SRC


* Environments
  
  A'ight, first I prefer tabs being 4 spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

  I'll be trying subword mode for now.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :config
    (global-subword-mode))
#+END_SRC

  So I can see what's happening in the =*compilation*= buffer:

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC

** Angular

#+BEGIN_SRC emacs-lisp
  (use-package ng2-mode
    :mode "\\.ts\\'")
#+END_SRC

** Ansible

#+BEGIN_SRC emacs-lisp
  (use-package ansible
   :after (yaml-mode)
   :mode ("\\.yml\\'"
	      "\\.yaml\\'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-ansible
   :after
   (company)
   :mode ("\\.yml\\'"
          "\\.yaml\\'")
   :config (add-to-list 'company-backends 'company-ansible))
#+END_SRC

** API Blueprint

#+BEGIN_SRC emacs-lisp
  (use-package apib-mode
    :mode "\\.apib\\'")
#+END_SRC

** Dockerfiles

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :mode "Dockerfile$")
#+END_SRC

** Elixir

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :ensure t
  :mode ("\\.exs\\'"
         "\\.ex\\'")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package alchemist
  :after (elixir-mode which-key)
  :config
  (which-key-add-major-mode-key-based-replacements 'elixir-mode
    "C-c a"     "alchemist"
    "C-c a m"   "mix"
    "C-c a m t" "mix-test"
    "C-c a X"   "hex"
    "C-c a c"   "compile"
    "C-c a e"   "execute"
    "C-c a p"   "project"
    "C-c a n"   "phoenix"
    "C-c a h"   "help"
    "C-c a i"   "iex"
    "C-c a v"   "eval"
    "C-c a o"   "macroexpand"
    "C-c a f"   "info")
   (add-hook 'before-save-hook 'elixir-format)
)
#+END_SRC

** Jinja2

#+BEGIN_SRC emacs-lisp
  (use-package jinja2-mode
    :mode "\\.j2\\'")
#+END_SRC

** JavaScript

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js\\'")
#+END_SRC

** =markdown=

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package grip-mode
    :after markdown-mode)
#+END_SRC

** Go

  Install =go-mode= and related packages

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
	:mode "\\.go\\'")

  (use-package go-errcheck)

  (use-package go-eldoc
	:config
	(add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package company-go
   :config
   (add-hook 'go-mode-hook (lambda ()
						 (set (make-local-variable 'company-backends) '(company-go))
						 (company-mode)))
   (add-hook 'before-save-hook 'gofmt-before-save)
   '(company-go-insert-arguments t))
#+END_SRC

  Setting =$GOPATH=

#+BEGIN_SRC emacs-lisp
  (setenv "GOPATH" (concat home "/go"))
  (jpdl/append-to-path (concat (getenv "GOPATH") "/bin"))
#+END_SRC

** Python

  =python-mode= duh

#+BEGIN_SRC emacs-lisp
  (use-package python-mode)
#+END_SRC

  Adding ~/.local/bin to load path. Needed by Jedi

#+BEGIN_SRC emacs-lisp
  (jpdl/append-to-path "~/.local/bin")
#+END_SRC

  =elpy= because it's nice.

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :config
    (elpy-enable))
#+END_SRC

  =anaconda-mode=

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :config
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC

  =anaconda-company=

#+BEGIN_SRC emacs-lisp
  (use-package company-anaconda
    :after company
    :config
    (add-to-list 'company-backends 'company-anaconda))
#+END_SRC


  # Using flycheck for syntax errors.
  # 
# #+BEGIN_SRC emacs-lisp
  # (add-hook 'elpy-mode-hook 'flycheck-mode)
# #+END_SRC
# 
  # PEP8 before saving
  # 
# #+BEGIN_SRC emacs-lisp
  # (use-package py-autopep8
    # :hook
     # (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
# #+END_SRC
# 
  # Jedi and stuff
  # 
# #+BEGIN_SRC emacs-lisp
  # (use-package company-jedi
    # :config
    # (add-to-list 'company-backends 'company-jedi)
    # (setq jedi:complete-on-dot t)
    # :hook
    # (add-hook 'python-mode-hook 'jedi:setup))
# #+END_SRC

** Rust

  TOML support.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :mode "\\.toml\\'")
#+END_SRC

  =rust-mode=

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'")
#+END_SRC

  Cargo and hooks

#+BEGIN_SRC emacs-lisp
  (use-package cargo
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC

  Flycheck4Rust

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-rust
    :hook (flycheck-mode . flycheck-rust-setup))
#+END_SRC

  And finally, =racer=

#+BEGIN_SRC emacs-lisp
  (use-package racer
    :hook ((rust-mode . racer-mode)
           (racer-mode . eldoc-mode)))
#+END_SRC

** sh

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** Terraform

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :config '(terraform-indent-level 4)
    :mode ("\\.tf$"
           "\\.tfvars$"
           "\\.tfstate$"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-terraform
	:after (company terraform-mode)
    :config (company-terraform-init))
#+END_SRC


#+BEGIN_SRC emacs-lisp

#+END_SRC

** =yaml-mode=

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode ("\\.yml\\'"
         "\\.yaml\\'"))
#+END_SRC

** =web-mode=

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
	:mode
    "\\.gohtml$"
	"\\.html$"
	"\\.php$")
#+END_SRC

  Setting things up:
  - color-related words with =rainbow-mode=
  - ident with 2 spaces

#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
			(lambda ()
			  (rainbow-mode)
			  (setq web-mode-markup-indent-offset 2)))
#+END_SRC

** =emmet-mode=

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
	:mode
	"\\.gohtml$"
    "\\.html$"
    "\\.php$")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-web
    :mode
	"\\.gohtml$"
    "\\.html$"
    "\\.php$"
    :config
    (add-to-list 'company-backends 'company-ansible))
#+END_SRC


* Org Mode
  
** General configuration for Org

*** Org bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
	:config
	(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC


*** Elipsis in org

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "...")
  ;; (setq org-ellipsis " ⤵")
#+END_SRC


*** Make TAB act if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
   (setq org-src-tab-acts-natively t)
#+END_SRC


*** Org-Reveal

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :pin melpa)
#+END_SRC


*** Make windmove work in org-mode

 #+BEGIN_SRC emacs-lisp
   (add-hook 'org-shiftup-final-hook 'windmove-up)
   (add-hook 'org-shiftleft-final-hook 'windmove-left)
   (add-hook 'org-shiftdown-final-hook 'windmove-down)
   (add-hook 'org-shiftright-final-hook 'windmove-right)
   (setq org-support-shift-select 'always)
 #+END_SRC


** Trying emacs-jupyter output

#+BEGIN_SRC emacs-lisp
(use-package emacs-jupyter
  :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (jupyter . t)))
#+END_SRC

Setting default parameters for python

#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                    (:session . "py")
                                                    (:kernel . "python3")))
#+END_SRC


* Editing Settings
  
** Install and configure =which-key=

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+END_SRC

** Configure =yasnippet=

  Tell me a package more awesome than yasnippet and fail.
  Saving my snippets @ ~/.emacs.d/snippets/text-mode.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
    (yas-global-mode 1))
#+END_SRC

** =ivy= and =counsel=

  They're cool, what can I do?

*** =ivy=

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :init
    (setq ivy-mode t)
    (setq ivy-count-format "(%d/%d) ") ; display (current/total) instead of just total
    (setq ivy-format-function 'ivy-format-function-line) ; highlight the entire line
    (setq ivy-use-selectable-prompt t))
#+END_SRC

*** =counsel=

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :init  
	(setq counsel-mode t))
#+END_SRC

*** Some =smex=

#+BEGIN_SRC emacs-lisp
  (use-package smex
	:init (smex-initialize))

#+END_SRC

** Switch and balance windows

#+BEGIN_SRC emacs-lisp
  (defun split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  
  (defun split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  
  (global-set-key (kbd "C-x 2") 'split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'split-window-right-and-switch)
#+END_SRC


* General stuff

Highlight parens 
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC


* General shortcuts

C(lic)k to kill
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-k") 'kill-buffer-and-window)
#+END_SRC


* Enjoy! =)
