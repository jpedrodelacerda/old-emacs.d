#+TITLE: Emacs Configuration
#+AUTHOR: João Pedro de Lacerda
#+EMAIL: jpedrodelacerda@gmail.com
#+OPTIONS: toc:nil num:nil

* $ whoami

#+BEGIN_SRC emacs-lisp
  (setq home (concat "/home/" (eval user-login-name)))
#+END_SRC

Enable ssh-agent for emacs server
#+BEGIN_SRC emacs-lisp
  (use-package keychain-environment
    :init (keychain-refresh-environment))
#+END_SRC


* Configure =use-package=

  This setup uses =use-package= to make sure that all packages are installed before loading them.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

Also, to ensure we always compile and use updated packages:

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+END_SRC


* =evil-mode=

  Disable abbrev expansion when hitting Escape.

#+BEGIN_SRC emacs-lisp
 (setq evil-want-abbrev-expand-on-insert-exit nil) 
#+END_SRC  

  Use =evil=:

#+BEGIN_SRC emacs-lisp
  (use-package evil
	:config
	(evil-mode 1)
    (setq evil-emacs-state-mode nil)
	:bind
	("C-s" . evil-write))
#+END_SRC

  Enable =surround= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+END_SRC

  Setting up =evil-org=:

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda () (evil-org-set-key-theme))))
#+END_SRC


* Utilities

#+BEGIN_SRC emacs-lisp

  (defun jpdl/create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent."
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))

  (defun jpdl/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun jpdl/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC


* UI Preferences
  

** Tweaking Window

***   Disabling menu bar and scroll bar because they just take space up.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

*** Disabling blinking cursor

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC
*** Getting rid of the tiny scroll bar on minibuffer:

#+BEGIN_SRC emacs-lisp
   (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC

*** We probably know which window we are using and where, so let's make the windows title more useful.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC


** No start-up-message
   
  Really, why would I want this?

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC


** Theming

*** First we need =all-the-icons=

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

<<<<<<< HEAD
*** Back to gruvbox.

#+BEGIN_SRC emacs-lisp
  (use-package gruvbox-theme 
    :config
	(load-theme 'gruvbox-dark-soft)
    (enable-theme 'gruvbox-dark-soft))
=======
*** Solarized Dark for now.

#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :config
	(load-theme 'solarized-dark t)
    (enable-theme 'solarized-dark))
>>>>>>> 6a4fbe5e67497761d393a7dd1c8297e12546e481
#+END_SRC

*** Powerline and airline-theme 

#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :init
    (setq powerline-default-separator 'arrow
          powerline-default-separator-dir (quote (left . right))
          powerline-height 18
          powerline-display-buffer-size nil
          powerline-display-hud nil
          powerline-display-mule-info nil
          powerline-gui-use-vcs-glyph t
          powerline-inactive1 '((t (:background "grey11" :foreground "#c5c8c6")))
          powerline-inactive2 '((t (:background "grey20" :foreground "#c5c8c6"))))
    :config
    (powerline-default-theme))
#+END_SRC
 
#+BEGIN_SRC emacs-lisp
  (use-package airline-themes
<<<<<<< HEAD
	:config
	(load-theme 'airline-gruvbox-dark t))
=======
    :config
    (load-theme 'airline-solarized-alternate-gui))
>>>>>>> 6a4fbe5e67497761d393a7dd1c8297e12546e481
#+END_SRC
 
  # ICONS!!!
  # 
# #+BEGIN_SRC emacs-lisp
  # (defun powerline-get-icon (name alt-sym help-message)
    # "Returns a propertized icon if available, otherwise, returns ALT-SYM."
    # (propertize alt-sym 'help-echo help-message))
	# 
  # (defun powerline-modified ()
    # (condition-case ex
        # (let ((state (vc-git-state (buffer-file-name))))
          # (cond ((buffer-modified-p)  (powerline-get-icon "pencil" "✦" "Modified buffer"))
                # ((eq state 'edited)   (powerline-get-icon "pencil" "✦" "Modified buffer, unregistered changes"))
                # ((eq state 'unregistered) (powerline-get-icon "question" "❓" "Unregistered file in VCS"))
                # ((eq state 'missing)  (powerline-get-icon "exclamation" "⁈" "File exists only in VCS, not on the hard disk"))
                # ((eq state 'ignored)  (powerline-get-icon "ban" "♟" "Ignored file in VCS"))
                # ((eq state 'added)    (powerline-get-icon "plus" "➕" "File will be registered in VCS in the next commit"))
                # (t " ")))
      # (error (powerline-get-icon "exclamation" "⁈" (car ex)))))
# #+END_SRC



** And this is supposed to be (+18), so no minors. (Just kidding, if you're under 18 just go play some Magic or whatever)

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config
	(minions-mode 1))
#+END_SRC


** Font and resizing

#+BEGIN_SRC emacs-lisp
  (setq default-font "Hack")
  (setq default-font-size 10)
  (setq current-font-size default-font-size)
  
  (setq font-change-increment 1.1)
  
  (defun font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat default-font "-" (number-to-string current-font-size)))
  
  (defun set-font-size ()
    "Set the font to `default-font' at `current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))
  
  (defun reset-font-size ()
    "Change font size back to `default-font-size'."
    (interactive)
    (setq current-font-size default-font-size)
    (set-font-size))
  
  (defun increase-font-size ()
    "Increase current font size by a factor of `font-change-increment'."
    (interactive)
    (setq current-font-size
          (ceiling (* current-font-size font-change-increment)))
    (set-font-size))
  
  (defun decrease-font-size ()
    "Decrease current font size by a factor of `font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq current-font-size
          (max 1
               (floor (/ current-font-size font-change-increment))))
    (set-font-size))
  
  (define-key global-map (kbd "C-)") 'reset-font-size)
  (define-key global-map (kbd "C-+") 'increase-font-size)
  (define-key global-map (kbd "C-=") 'increase-font-size)
  (define-key global-map (kbd "C-_") 'decrease-font-size)
  (define-key global-map (kbd "C--") 'decrease-font-size)
  
  (reset-font-size)
#+END_SRC


** Handling buffers/windows and shit

  To move between buffers with Meta and arrows
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-<up>") 'windmove-up)
  (global-set-key (kbd "M-<down>") 'windmove-down)
  (global-set-key (kbd "M-<right>") 'windmove-right)
  (global-set-key (kbd "M-<left>") 'windmove-left)
#+END_SRC
   

** Excuse me, sir. Do you know where I am?

  Async relative line numbering

#+BEGIN_SRC emacs-lisp
  (use-package nlinum-relative
	:config
	(global-nlinum-relative-mode)
	(nlinum-relative-setup-evil))
#+END_SRC


** Highlighting the uncommitted changes

  Use =diff-hl= to highlight uncommitted changes when programming.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
	:config
	(add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
	(add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+END_SRC


* Project Management

  Some general packages for like... everything. From writing to programming.
  Auto-completion, searches, version control...

** =ag=

  Extremely powerful searcher. Haven't decided between this and =helm-ag=, tho.

#+BEGIN_SRC emacs-lisp
  (use-package ag)
#+END_SRC

** =helm=

  Well, helm is awesome, right. So why the +hell+ heck not?!
  Here I set:
    - =helm-map= keys:
		  - =TAB= to execute some action,
		  - =C-z= to select
	- General shortcuts:
		  - =C-x C-b= to open helm-mini
		  - =C-x C-f= to find file with helm
		  - =C-x C-d= to find file with helm on projectile

#+BEGIN_SRC emacs-lisp
  (use-package helm
	:config
	(helm-autoresize-mode 1)
	(setq helm-autoresize-min-height 25)
	(setq helm-autoresize-max-height 35)
	(define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
	(define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
	(define-key helm-map (kbd "C-z") #'helm-select-action)
	:bind (("C-x C-b" . helm-mini)
	       ("C-x C-f" . helm-find-files)
	       ("C-x C-d" . helm-projectile-find-file)))
#+END_SRC
   

** =company=

  I mean... we want this all the time, right?!
  Here I set:
	- Company to sort suggestions by occurrence
    - General shortcuts:
		  - =C-TAB= to select next suggestion
		  - =C-'= to accept suggestion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-transformers '(company-sort-by-occurrence))
    (add-to-list 'company-backends 'company-ansible)
    :bind
    ("C-<tab>" . company-complete-common-or-cycle)
	("C-'" . company-complete))

  (global-company-mode)

#+END_SRC

  Company with fuzzing...

#+BEGIN_SRC emacs-lisp
  (use-package company-flx
    :after
    (company)
	:config
	(company-flx-mode +1))
#+END_SRC

** YouCompleteMe

  Best autocompletion ever.

#+BEGIN_SRC emacs-lisp
  (use-package ycmd
	:init
    (setq ycmd-server-command `("python" ,(concat home "/YouCompleteMe/third_party/ycmd/ycmd")))
    (set-variable 'ycmd-global-config (concat home "/YouCompleteMe/.ycm_extra_conf.py"))
	(add-hook 'after-init-hook #'global-ycmd-mode))
#+END_SRC

  Company and YCM

#+BEGIN_SRC emacs-lisp
  (use-package company-ycmd
    :init
    (company-ycmd-setup))  
#+END_SRC



** =dumb-jump=

  It seems nice and handy. Because it is.
  Here I set:
    - General shortcuts:
		  - =M-.= to jump to definition

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :config
    (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+END_SRC

** =flycheck=

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config
    (global-flycheck-mode))
#+END_SRC

** =magit=

  Magit rocks, there's no denying. Using =evil= keybindings with =evil-mode=
  Here I set:
    - General shortcuts:
		  - =C-x g= to see status menu
	- following [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes beyond 50 characters
	- starting commit message buffer with insert state

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)
  
    :config
    (use-package evil-magit)
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
  
    ;;(with-eval-after-load 'magit-remote
    ;;(magit-define-popup-action 'magit-push-popup ?P
    ;;    'magit-push-implicitly--desc
    ;;    'magit-push-implicitly ?p t))
  
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

  =evil-magit=

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit)
#+END_SRC


** =projectile= 

  Well, projectile is the way to go when we talk about projects on emacs.
  Here I set:
    - General shortcuts:
		  - =C-c p= to projectile menu
				- 4: other-window
				- 5: other-frame
				- s: search
				- x: execute
	- Completion: helm

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-mode 1)
  (setq projectile-project-search-path '("~/"))
  (setq projectile-completion-system 'helm)
  (which-key-add-key-based-replacements "C-c p 4" "other-window"
                                        "C-c p 5" "other-frame"
                                        "C-c p s" "search"
                                        "C-c p x" "execute")
  :bind-keymap ("C-c p" . projectile-command-map))
#+END_SRC

** =treemacs= and =treemacs-evil=

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :config
    (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
    :bind ("M-v" . treemacs ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-evil)
#+END_SRC

** =helm-company=

  If I ever want to complete with helm, just =C-:=.
#+BEGIN_SRC emacs-lisp
  (use-package helm-company
    :bind ("C-:" . helm-company))
#+END_SRC

** =helm-projectile=

  Helm all the way, bro.
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure t
    :init (helm-projectile-on))
#+END_SRC

** =undo-tree=

   Because shit happens.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)
#+END_SRC

** =smartparens=

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :init
    :bind ("C-SPC" . sp-forward-sexp)
    :config
    (sp-pair "{" nil :post-handlers '((jpdl/create-newline-and-enter-sexp "RET")))
    (sp-pair "[" nil :post-handlers '((jpdl/create-newline-and-enter-sexp "RET")))
    (sp-pair "(" nil :post-handlers '((jpdl/create-newline-and-enter-sexp "RET")))
    (require 'smartparens-config)
    (smartparens-global-mode 1))
#+END_SRC

** Nerd-Commenter

#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
	:bind ("M-;" . evilnc-comment-or-uncomment-lines))
#+END_SRC


* Programing Environments
  
  A'ight, first I prefer tabs being 4 spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

  I'll be trying subword mode for now.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :config
    (global-subword-mode))
#+END_SRC

  So I can see what's happening in the =*compilation*= buffer:

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC

** Go

  Install =go-mode= and related packages

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'")
  (use-package go-errcheck)
  (use-package go-eldoc
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))
  ;(use-package company-go
  ;  :config
  ;  (add-hook 'go-mode-hook (lambda ()
  ;                        (set (make-local-variable 'company-backends) '(company-go))
  ;                        (company-mode)))
  ;  (add-hook 'before-save-hook 'gofmt-before-save))
#+END_SRC

  Setting =$GOPATH=

#+BEGIN_SRC emacs-lisp
  (setenv "GOPATH" (concat home "/go"))
  (jpdl/append-to-path (concat (getenv "GOPATH") "/bin"))
#+END_SRC


** Rust

  TOML support.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :mode "\\.toml\\'")
#+END_SRC

  =rust-mode=

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'")
#+END_SRC

  Cargo and hooks

#+BEGIN_SRC emacs-lisp
  (use-package cargo
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC

  Flycheck4Rust

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-rust
    :hook (flycheck-mode . flycheck-rust-setup))
#+END_SRC

  And finally, =racer=

#+BEGIN_SRC emacs-lisp
  (use-package racer
    :hook ((rust-mode . racer-mode)
           (racer-mode . eldoc-mode)))
#+END_SRC


** Python

  =python-mode= duh

#+BEGIN_SRC emacs-lisp
  (use-package python-mode)
#+END_SRC

  Adding ~/.local/bin to load path. Needed by Jedi

#+BEGIN_SRC emacs-lisp
  (jpdl/append-to-path "~/.local/bin")
#+END_SRC

  =elpy= because it's nice.

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :config
    (elpy-enable))
#+END_SRC

  =anaconda-mode=

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :config
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC

  =anaconda-company=

#+BEGIN_SRC emacs-lisp
  (use-package company-anaconda
    :after company
    :config
    (add-to-list 'company-backends 'company-anaconda))
#+END_SRC


  # Using flycheck for syntax errors.
  # 
# #+BEGIN_SRC emacs-lisp
  # (add-hook 'elpy-mode-hook 'flycheck-mode)
# #+END_SRC
# 
  # PEP8 before saving
  # 
# #+BEGIN_SRC emacs-lisp
  # (use-package py-autopep8
    # :hook
     # (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
# #+END_SRC
# 
  # Jedi and stuff
  # 
# #+BEGIN_SRC emacs-lisp
  # (use-package company-jedi
    # :config
    # (add-to-list 'company-backends 'company-jedi)
    # (setq jedi:complete-on-dot t)
    # :hook
    # (add-hook 'python-mode-hook 'jedi:setup))
# #+END_SRC


** sh

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** =web-mode=

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode
    "\\.html$"
    "\\.php$")
#+END_SRC

  Setting things up:
  - color-related words with =rainbow-mode=
  - ident with 2 spaces

#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (rainbow-mode)
              (setq web-mode-markup-indent-offset 2)))
#+END_SRC


* Org Mode

** General configuration for Org

*** Org bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
	:config
	(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC


*** Elipsis in org

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC


*** Make TAB act if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
   (setq org-src-tab-acts-natively t)
#+END_SRC


*** Org-Reveal

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :pin melpa)
#+END_SRC


*** Make windmove work in org-mode

 #+BEGIN_SRC emacs-lisp
   (add-hook 'org-shiftup-final-hook 'windmove-up)
   (add-hook 'org-shiftleft-final-hook 'windmove-left)
   (add-hook 'org-shiftdown-final-hook 'windmove-down)
   (add-hook 'org-shiftright-final-hook 'windmove-right)
   (setq org-support-shift-select 'always)
 #+END_SRC


* Editing Settings
  
** Install and configure =which-key=

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+END_SRC

** Configure =yasnippet=

  Tell me a package more awesome than yasnippet and fail.
  Saving my snippets @ 

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
    (yas-global-mode 1))
#+END_SRC

** =ivy= and =counsel=

  They're cool, what can I do?

*** =ivy=

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :init
    (setq ivy-mode t)
    (setq ivy-count-format "(%d/%d) ") ; display (current/total) instead of just total
    (setq ivy-format-function 'ivy-format-function-line) ; highlight the entire line
    (setq ivy-use-selectable-prompt t))
#+END_SRC

*** =counsel=

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :init  
	(setq counsel-mode t))
#+END_SRC

*** Some =smex=

#+BEGIN_SRC emacs-lisp
  (use-package smex
	:init (smex-initialize))

#+END_SRC

** Switch and balance windows

#+BEGIN_SRC emacs-lisp
  (defun split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  
  (defun split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  
  (global-set-key (kbd "C-x 2") 'split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'split-window-right-and-switch)
#+END_SRC


* General shortcuts

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-k") 'kill-buffer-and-window)
#+END_SRC
